#+TITLE: Rime: Nix CLI Wrapper Generators

* About
Sometimes I felt the need to add pre/post hooks to Nix CLI commands; particularly for the flakes.
For example "update all sub-flakes when ~nix flake update~ is called on a parent".

The goal of this repo is collect a few wrapper generators and useful routines for extending the base TUI.

** "Rime"
Thin crystal layer of ice and snow formed by fog; particularly on branches.

** libs and types
Given that the Nix flakes interfaces revolve around URI parsing, I've defined some URI parsers and types ( using [[https://code.tvl.fyi/plain/nix/yants/default.nix][YANTS]] ).

I initially took a shot at exposing Nix's builtin =parseFlakeRef= or =fetchTree= routines, but they were rooted in the actual fetching of flakes and trees to port as standalone routines.
It could be done, but it's less effort for me to just write that stuff in Nix anyway and avoid fooling with plugins.

** Flake Ref Types
These YANTS types can be used to assert the validity of "flake refs", like those used as flake inputs, or arguments to =builtins.fetchTree=.

#+BEGIN_SRC nix
  nix-repl> :p map ( builtins.getFlake "github:aakropotkin/rime/main" ).lib.ytypes.FlakeRef.Structs.flake-ref-github [
    { url = "github:aakropotkin/rime/main"; }
    { type = "github"; url = "github:aakropotkin/rime/main"; }
    { type = "github"; owner = "aakropotkin"; repo = "rime"; ref = "main"; }
  ]
  =>
  [ { url = "github:aakropotkin/rime/main"; }
    { type = "github"; url = "github:aakropotkin/rime/main"; }
    { owner = "aakropotkin"; ref = "main"; repo = "rime"; type = "github"; }
  ]
#+END_SRC

These types will =throw= on failure.
#+BEGIN_SRC nix
  nix-repl> lib.ytypes.FlakeRef.Structs.flake-ref-file { type = "file"; url = "file:./foo"; }
  =>
  { type = "file"; url = "file:./foo"; }

  nix-repl> lib.ytypes.FlakeRef.Structs.flake-ref-file { type = "file"; path = "./foo"; }
  =>
  error: {
           path = "./foo";
           type = "file";
         } does not conform to restriction 'flake-ref[file]'
#+END_SRC

*** Available Checks
- =flake-ref= abstract form, allows any combination of fields used by children.
- =flake-ref-indirect= an ~inputs.foo.follows = "bar";~ style ref.
- =flake-ref-path=
- =flake-ref-file=
- =flake-ref-tarball=
- =flake-ref-git=
- =flake-ref-github=
- =flake-ref-sourcehut= ( basically an alias of =github=, not tested exhaustibly )
- =flake-ref-mercurial= ( basically an alias of =github=, not tested exhaustibly )

** Utilities and Scripts
Rime provides a handful of useful scripts that help extract info from Nix.
These are generally pretty simple, and most anyone could cook these up as shell aliases;
but exposing them in this flake allows me to lock and consume them in other projects

*** =nix-outputs=
Given a package name or installable URI, print the available outputs for the derivation.
This simply dumps =<DERIVATION>.outputs= as a JSON list.

Use this to quickly look up extras that might hold headers, libs, docs, etc for a package.

If no URI is given, arg is interpreted as an attr on =nixpkgs=.

*** =nix2json=
Naively convert a Nix file to JSON.
Faster than =nix-serialize=, but will fail on input that contains functions or store paths.

*** =nix-serialize=
Best effort conversion from Nix to a /flat/ representation.

Similar to =nixpkgs#lib.generators.toPretty= but supports =__serial= functors from
[[https://github.com/aameen-tulip/at-node-nix][github:aameen-tulip/at-node-nix]], and will
completely remove fields that cannot be converted to JSON.

**** Options
- =--json=
Export JSON instead of a Nix expression.

*** =nix-prefetch-tree=
Prefetch /flake ref/ URI ( it doesn't need to point to a flake ) and print the "locked"
attribute representation.

This can be used to lookup =narHash= for URLs quickly.
I basically made this entire script to /try catch/ to create =narHash= locks on large numbers
of tarballs. 

By default we assume you assume you are prefetching a tarball, but adding =--type ARG= allows
you to prefetch any type of ref.

**** Options
- =-K, --fallback=
When fetching tarballs, if unpacking fails ( due to archive permissions ) fall back to
fetching as a regular file.
